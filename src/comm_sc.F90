!--------------------------------------------------------------------------------------------------------------
subroutine COPYATOMS_SC(imode, dr, atype, rreal, v, f, q)
use atoms; use pqeq_vars
!
! TODO: update notes here
!
! In this subroutine, boundary atoms are copied to neighbour nodes. Three subroutines, 
! <store_atoms()>, <send_recv()> and  <append_atoms()> work together, shareing variables 
! <sbuffer>, <rbuffer>, <ne>, <na>, <ns> and <nr>. 
!
!--- Variables --- 
!<dflag>:  Direction FLAG specifing the direction of communication.
!          1 +x, 2 -x, 3 +y, 4 -y, 5 +z, 6 -z. 
!<parity>:  PARITY of a node in <dflag> direction. 
!<nlayer>:  Nr of LAYERs to be copied. COPYATOMS() features two different modes, migration mode and copy mode.
!           <nlayer> will be used as a flag to distinguish them. 
!
!--- Shared Variables ---
!<ne>: # of elements one atom has.
!   Example) in copy mode, three positions[xyz] + charge + atomtype = 5 elements. 
!<na>, <ns> & <nr>: Nr of All of transfered elemetns, Number of elements to be Sent, and Recieved one respectivly.
!        
!--- Subroutines ---
!<store_atoms()>: store boundary atoms information.
!<send_recv()):   send & receive. 
!<append_atoms()>: append received infromation into array.  deallocate <sbuffer> & <rbuffer>
!
!--------------------------------------------------------------------------------------------------------------
implicit none

integer,intent(IN) :: imode 
real(8),intent(IN) :: dr(3)
real(8) :: atype(NBUFFER), q(NBUFFER)
real(8) :: rreal(NBUFFER,3),v(NBUFFER,3),f(NBUFFER,3)

real(8) :: pos(NBUFFER,3) ! <- normalized coordinate

integer :: i,tn1,tn2, dflag
integer :: ni, ity

integer :: ti,tj,tk,tti,ttj

integer,parameter :: dinv(6)=(/2,1,4,3,6,5/)

call system_clock(tti,tk)


!--- Normalized local coordinate will be used through this function. 
!--- How many atom coords need to be normalized depends on who calls this.
!--- For example function calls during QEq (MODE_QCOPY1 & MODE_QCOPY2) assume
!--- atom information of the extended domain regions. 
!if (imode > MODE_SC) then
!if (imode == MODE_COPY_SC) then
!   call xu2xs(rreal,pos,max(NATOMS,copyptr_sc(5)))
!elseif (imode == MODE_COPY .or. imode == MODE_MOVE) then
!if (imode == MODE_COPY_SC) call xu2xs(rreal,pos,max(NATOMS,copyptr(6)))
call xu2xs(rreal,pos,max(NATOMS,copyptr_sc(6)))
!endif

!--- clear total # of copied atoms, sent atoms, recieved atoms
na=0;ns=0;nr=0

!--- REMARK: note that MODE_CPBK depends on copyptr() generated during MODE_COPY.
!--- Since cached atoms are stored after the resident atoms (i.e. i > NATOMS), 
!--- initialize the cache atom pointer 0th elem with NATOMS.

!--- REMARK: 
!--- copyptr_sc() is used for 3-way communication in SC algorithm. 
!--- It only update if imode = MODE_QCOPY1_SC or imode = MODE_QCOPY2_SC

!---I add this
if (imode == MODE_COPY_SC) then
   copyptr_sc(:) = 0
endif

!copyptr(0)=NATOMS
copyptr_sc(0)=NATOMS

!--- set the number of data per atom 
select case(imode)
   case(MODE_COPY)
      ne = NE_COPY
   case(MODE_MOVE)
      ne = NE_MOVE
   case(MODE_CPBK)
      ne = NE_CPBK
   case(MODE_QCOPY1)
      ne = NE_QCOPY1
   case(MODE_QCOPY2)
      ne = NE_QCOPY2
   case(MODE_COPY_SC)
      ne = NE_COPY_SC
   case(MODE_CPBK_SC)
      ne = NE_CPBK
   case(MODE_CPBKSHELL_SC)
      ne = NE_CPBK
   case(MODE_QCOPY1_SC)
      ne = NE_QCOPY1_SC
   case(MODE_QCOPY2_SC)
      ne = NE_QCOPY2_SC
   case(MODE_CPHSH_SC)
      ne = NE_CPHSH_SC
   case(MODE_CPGSGT_SC)
      ne = NE_CPGSGT_SC
   case(MODE_CPFPQEQ_SC)
      ne = NE_CPFPQEQ_SC
   case default
      print'(a,i3)', "ERROR: imode doesn't match in COPYATOMS: ", imode
end select

do dflag=1, 6
   tn1 = target_node(dflag)
   tn2 = target_node(dinv(dflag))
   i = (dflag+1)/2  !<- [123]

   if(imode==MODE_CPBK) then  ! communicate with neighbors in reversed order
      tn1 = target_node(7-dinv(dflag)) ! <-[563412] 
      tn2 = target_node(7-dflag) ! <-[654321] 
      i = (6-dflag)/2 + 1         ! <-[321]
 
   ! communicate with neighbors in +direction in reversed order (+z, +y, +x)
   !elseif(imode == MODE_CPFPQEQ_SC .or. imode == MODE_CPBKSHELL_SC .or. imode == MODE_CPBK_SC .or. imode==MODE_CPHSH_SC &
   !        .or. imode==MODE_CPGSGT_SC) then  
   elseif(imode < 0 .and. abs(imode) > MODE_SC) then
      if (MOD(dflag,2) == 1) then
         cycle
      endif
      tn2 = target_node(7-dinv(dflag)) ! <-[563412] 
      tn1 = target_node(7-dflag) ! <-[654321] 
      i = (6-dflag)/2 + 1         ! <-[321]
   
   !elseif(imode==MODE_QCOPY1_SC .or. imode==MODE_QCOPY2_SC .or. imode==MODE_COPY_SC) then ! for SC, communicate only x+,y+, and z+
   elseif(abs(imode) > MODE_SC) then
      if (MOD(dflag,2) == 1) then
         !copyptr_sc(dflag) = copyptr_sc(dflag-1)
         !copyptr(dflag-1) = copyptr_sc(dflag-1)
         !copyptr(dflag) = copyptr_sc(dflag)
         cycle
      endif
   endif

#ifdef MATT_DEBUG
   print '(a,i6,i3,i10,i10)', "=============Begin imode,dflag, ns/ne, na/ne =", imode,dflag, ns/ne, na/ne
   print '(a,7i6)',"copyptr:", copyptr(:)
   print '(a,7i6)',"copyptr_sc:", copyptr_sc(:)
#endif

   call store_atoms_sc(tn1, dflag, imode, dr)
   !call send_recv_sc(tn1, tn2, myparity(i))
   call send_recv_sc(tn1, tn2, dflag)
   call append_atoms_sc(dflag, imode)
   !call MPI_BARRIER(MPI_COMM_WORLD, ierr)
   !copyptr(dflag) = copyptr_sc(dflag)

#ifdef MATT_DEBUG
   print '(a,i6,i3,i10,i10)', "=============  End imode,dflag, ns/ne, na/ne =", imode,dflag, ns/ne, na/ne
   print '(a,7i6)',"copyptr:", copyptr(:)
   print '(a,7i6)',"copyptr_sc:", copyptr_sc(:)
#endif

enddo


if(imode==MODE_MOVE) then
!--- remove atoms which are transfered to neighbor nodes.
   ni=0
   do i=1, NATOMS + na/ne
      ity = nint(atype(i))
!--- if atype is smaller than zero (this is done in store_atoms), ignore the atom.
      if(ity>0) then
        ni=ni+1
        pos(ni,1:3) = pos(i,1:3)
        v(ni,1:3) = v(i,1:3)
        atype(ni) = atype(i)
        q(ni) = q(i)
        qs(ni) = qs(i)
        qt(ni) = qt(i)
        qsfp(ni) = qsfp(i)
        qsfv(ni) = qsfv(i)
!--- For PQEq
        spos(ni,1:3) = spos(i,1:3)
      endif
   enddo 

!--- update the number of resident atoms
   NATOMS=ni

endif

!--- by here, we got new atom positions in the normalized coordinate, need to update real coordinates.
!if(imode== MODE_COPY .or. imode == MODE_MOVE) call xs2xu(pos,rreal,copyptr(6))
!if(imode== MODE_COPY_SC) call xs2xu(pos,rreal,copyptr_sc(5))
!if(imode== MODE_COPY_SC .or. imode == MODE_MOVE .or. imode == MODE_COPY) call xs2xu(pos,rreal,copyptr(6))
if (imode == MODE_COPY_SC .or. imode == MODE_MOVE) then
   call xs2xu(pos,rreal,copyptr_sc(6))
   copyptr(:) = copyptr_sc(:)
endif


!--- for array size stat
if(mod(nstep,pstep)==0) then
  ni=nstep/pstep+1
  if(imode==MODE_MOVE) maxas(ni,4)=na/ne
  if(imode==MODE_COPY) maxas(ni,5)=na/ne
  if(imode==MODE_COPY_SC) maxas(ni,5)=na/ne
endif



call system_clock(ttj,tk)
it_timer(4)=it_timer(4)+(ttj-tti)

return
CONTAINS 

!--------------------------------------------------------------------------------------------------------------
subroutine send_recv_sc(tn1, tn2, dflag)
use atoms
! shared variables::  <ns>, <nr>, <na>, <sbuffer()>, <rbuffer()>
! This subroutine only takes care of communication part. won't be affected by wether atom migration or atom 
! copy mode. 
!--------------------------------------------------------------------------------------------------------------
implicit none
integer,intent(IN) ::tn1, tn2, dflag
integer :: recv_stat(MPI_STATUS_SIZE),ierr2(MPI_STATUS_SIZE)
real(8) :: recv_size

!--- if the traget node is the node itself, atoms informations are already copied 
!--- to <rbuffer> in <store_atoms()>. Nothing to do here. Just return from this subroutine.

if(myid==tn1) return 

call system_clock(ti,tk)

     nr = 13*ns
     call CheckSizeThenReallocate(rbuffer,nr)
#ifdef DEBUG_COMM
     call MPI_BARRIER(MPI_COMM_WORLD, ierr)
     print '(a20,6i10)','dflag,myid,tn1,tn2,ns,nr',dflag,myid,tn1,tn2,ns,nr
#endif
     ! the number of elements per data packet has to be greater than 1, for example NE_COPY = 10.
     ! if ns == 0, send one double to tell remote rank that there will be no atom data to be sent. 
     if (ns > 0) then 
       call MPI_SENDRECV(sbuffer, ns, MPI_DOUBLE_PRECISION, tn1, 10+dflag, &
                         rbuffer, nr, MPI_DOUBLE_PRECISION, tn2, 10+dflag, MPI_COMM_WORLD, recv_stat,ierr)
     else
       call MPI_SENDRECV(1, 1, MPI_DOUBLE_PRECISION, tn1, 10+dflag, &
                         rbuffer, nr, MPI_DOUBLE_PRECISION, tn2, 10+dflag, MPI_COMM_WORLD, recv_stat,ierr)
     endif
     call MPI_Get_count(recv_stat, MPI_DOUBLE_PRECISION, nr, ierr2)
     !call CheckSizeThenReallocate(rbuffer,nr)

#ifdef DEBUG_COMM
     call MPI_BARRIER(MPI_COMM_WORLD, ierr)
     call sleep(1)
     if (myid == 0) print *,'================================'
     call sleep(1)
#endif
     ! the number of elements per data packet has to be greater than 1, for example NE_COPY = 10.
     ! nr == 1 means no atom data to be received. 
     if(nr==1) nr=0 

!endif

call system_clock(tj,tk)
it_timer(25)=it_timer(25)+(tj-ti)

end subroutine

!--------------------------------------------------------------------------------------------------------------
subroutine store_atoms_sc(tn, dflag, imode, dr)
use atoms
! <nlayer> will be used as a flag to change the behavior of this subroutine. 
!    <nlayer>==0 migration mode
!            > 0 copy mode
! shared variables::  <ns>, <nr>, <na>, <ne>, <sbuffer()>, <rbuffer()>
!--------------------------------------------------------------------------------------------------------------
implicit none
integer,intent(IN) :: tn, dflag, imode 
real(8),intent(IN) :: dr(3)

integer :: n,ni,is
real(8) :: sft 
integer :: cptridx, copyptr_last, is_prior, l2g

integer :: cptridx_ind_sc(0:6) = (/0,0,0,0,2,0,4/) !only use cptridx_ind_sc[6,4,2] = 4,2,0
call system_clock(ti,tk)

!--- reset the number of atoms to be sent
ns=0

cptridx=((dflag-1)/2)*2 ! <- [024] for SC


!if (abs(imode) > MODE_SC) then
!   if (cptridx > 0) cptridx = cptridx - 1   !<- [013] For SC
!endif

!if(imode/=MODE_CPBK .and. imode /=MODE_CPHSH_SC .and. imode /= MODE_CPGSGT_SC .and. imode/=MODE_CPBK_SC &
!   .and. imode /= MODE_CPBKSHELL_SC .and. imode /= MODE_CPFPQEQ_SC) then
if (imode > 0) then !non-copyback mode

!--- # of elements to be sent. should be more than enough. 
   !if (imode == MODE_COPY_SC .or. imode == MODE_QCOPY1_SC .or. imode == MODE_QCOPY2_SC) then
   ni = copyptr_sc(cptridx)*ne
!--- <sbuffer> will deallocated in store_atoms.
   call CheckSizeThenReallocate(sbuffer,ni)

!--- get the coordinate Index to be Shifted.
   is = int((dflag-1)/2) !<- [012] means [xyz]

!--- When atom moves to neighbor nodes, their coordinates must be shifted. 
!--- xshift() returns the edge length of one node assuming all of node size is same.
   sft=xshift(dflag)

!--- determine the last copy index for either SC or normal communication
   !if (imode == MODE_COPY_SC .or. imode == MODE_QCOPY1_SC .or. imode == MODE_QCOPY2_SC) then
   !if (imode > MODE_SC) then
      !if (cptridx > 0) cptridx = cptridx - 1   !<- [013] For SC
   !   copyptr_last = copyptr_sc(cptridx)
   !else
   !   copyptr_last = copyptr(cptridx)
   !endif
!--- start buffering data depending on modes. all copy&move modes use buffer size, dr, to select atoms.
   do n=1, copyptr_sc(cptridx)

      if(inBuffer(dflag,n,dr)) then
      
        select case(imode)
        case(MODE_MOVE)
           sbuffer(ns+1:ns+3) = pos(n,1:3)
           sbuffer(ns+1+is) = sbuffer(ns+1+is) + sft
           sbuffer(ns+4:ns+6) = v(n,1:3)
           sbuffer(ns+7) = atype(n)
           sbuffer(ns+8) = q(n)
           sbuffer(ns+9) = qs(n)
           sbuffer(ns+10) = qt(n)
           sbuffer(ns+11) = qsfp(n)
           sbuffer(ns+12) = qsfv(n)
           sbuffer(ns+13:ns+15) = spos(n,1:3)
  
!--- In append_atoms subroutine, atoms with <atype>==-1 will be removed
           atype(n) = -1.d0 

        case(MODE_COPY)
           sbuffer(ns+1:ns+3) = pos(n,1:3)
           sbuffer(ns+1+is) = sbuffer(ns+1+is) + sft
           sbuffer(ns+4) = atype(n)
           sbuffer(ns+5) = q(n)
           sbuffer(ns+6) = dble(n)
           sbuffer(ns+7) = qs(n)
           sbuffer(ns+8) = qt(n)
           sbuffer(ns+9) = hs(n)
           sbuffer(ns+10) = ht(n)
           sbuffer(ns+11:ns+13) = spos(n,1:3)

        case(MODE_QCOPY1)
           sbuffer(ns+1) = qs(n)
           sbuffer(ns+2) = qt(n)

        case(MODE_QCOPY2)
           sbuffer(ns+1) = hs(n)
           sbuffer(ns+2) = ht(n)
           sbuffer(ns+3) = q(n)

        case(MODE_COPY_SC)
           sbuffer(ns+1:ns+3) = pos(n,1:3)
           sbuffer(ns+1+is) = sbuffer(ns+1+is) + sft
           sbuffer(ns+4) = atype(n)
           sbuffer(ns+5) = q(n)
           sbuffer(ns+6) = dble(n)
           sbuffer(ns+7) = qs(n)
           sbuffer(ns+8) = qt(n)
           sbuffer(ns+9) = hs(n)
           sbuffer(ns+10) = ht(n)
           sbuffer(ns+11:ns+13) = spos(n,1:3)

        case(MODE_QCOPY1_SC)
           sbuffer(ns+1) = qs(n)
           sbuffer(ns+2) = qt(n)
           !sbuffer(ns+3) = fpqeq(n)
           !sbuffer(ns+4) = dble(n)

        case(MODE_QCOPY2_SC)
           sbuffer(ns+1) = hs(n)
           sbuffer(ns+2) = ht(n)
           sbuffer(ns+3) = q(n)
           !sbuffer(ns+4) = dble(n)

        end select 

!--- increment the number of atoms to be sent 
        ns = ns + ne
     endif

   enddo

!===== FORCE COPYBACK MODE ===========================================================
else if(imode==MODE_CPBK) then

   is = 7 - dflag !<- [654321] reversed order direction flag

   n = copyptr(is) - copyptr(is-1) + 1
   call CheckSizeThenReallocate(sbuffer,n*ne)

   do n=copyptr(is-1)+1, copyptr(is)
      sbuffer(ns+1) = dble(frcindx(n))
      sbuffer(ns+2:ns+4) = f(n,1:3)

!--- chenge index to point next atom.
      ns=ns+ne
   enddo
!=========================================================== FORCE COPYBACK MODE ====

!===== HSH COPYBACK MODE for SC algorithm of PQeQ==========================
else if(imode==MODE_CPBK_SC) then
!   print *, "storing hshs and hsht"
!   is = 7 - dflag !<- [654321] reversed order direction flag
!   is = 7 - dflag !<- [531] reversed order direction flag
   is = 6 - dflag + 2 !<- [642] reversed order direction flag

#ifdef MATT_COMM_DEBUG
   print '(a,3i5)',"Start MODE_CPHSH_SC: is, is-2, dflag:", is, is-2,dflag
#endif

   n = copyptr_sc(is) - copyptr_sc(is-2) + 1
   !n = copyptr_sc(is) - copyptr_sc(is_prior) + 1
   call CheckSizeThenReallocate(sbuffer,n*ne)

   !do n=copyptr_sc(is-2)+1, copyptr_sc(is)
   do n=copyptr_sc(is-2)+1, copyptr_sc(is)
      sbuffer(ns+1) = dble(scindx(n))
      sbuffer(ns+2:ns+4) = f(n,1:3)
!--- chenge index to point next atom.
      ns=ns+ne
   enddo
!=========================================================== FORCE COPYBACK MODE ====

!===== HSH COPYBACK MODE for SC algorithm of PQeQ==========================
else if(imode==MODE_CPBKSHELL_SC) then
!   print *, "storing hshs and hsht"
!   is = 7 - dflag !<- [654321] reversed order direction flag
!   is = 7 - dflag !<- [531] reversed order direction flag
   !is = 6 - dflag !<- [531] reversed order direction flag
   is = 6 - dflag + 2 !<- [642] reversed order direction flag
   !is_prior = cptridx_ind_sc(is)

#ifdef MATT_COMM_DEBUG
   print '(a,3i5)',"Start MODE_CPHSH_SC: is, is-2, dflag:", is, is-2,dflag
#endif

   n = copyptr_sc(is) - copyptr_sc(is-2) + 1
   !n = copyptr_sc(is) - copyptr_sc(is_prior) + 1
   call CheckSizeThenReallocate(sbuffer,n*ne)

   do n=copyptr_sc(is-2)+1, copyptr_sc(is)
   !do n=copyptr_sc(is_prior)+1, copyptr_sc(is)
      sbuffer(ns+1) = dble(scindx(n))
      sbuffer(ns+2:ns+4) = sforce(n,1:3)
!--- chenge index to point next atom.
      ns=ns+ne
   enddo
!=========================================================== FORCE COPYBACK MODE ====



!===== HSH COPYBACK MODE for SC algorithm of PQeQ==========================
else if(imode==MODE_CPHSH_SC) then
!   print *, "storing hshs and hsht"
!   is = 7 - dflag !<- [654321] reversed order direction flag
!   is = 7 - dflag !<- [531] reversed order direction flag
!   is = 6 - dflag !<- [531] reversed order direction flag
   is = 6 - dflag + 2 !<- [642] reversed order direction flag
   !is_prior = cptridx_ind_sc(is)

#ifdef MATT_COMM_DEBUG
   print '(a,3i5)',"Start MODE_CPHSH_SC: is, is-2, dflag:", is, is-2,dflag
#endif

   n = copyptr_sc(is) - copyptr_sc(is-2) + 1
   !n = copyptr_sc(is) - copyptr_sc(is_prior) + 1
   call CheckSizeThenReallocate(sbuffer,n*ne)

   do n=copyptr_sc(is-2)+1, copyptr_sc(is)
   !do n=copyptr_sc(is_prior)+1, copyptr_sc(is)
      sbuffer(ns+1) = dble(scindx(n))
      sbuffer(ns+2) = hshs(n)
      sbuffer(ns+3) = hsht(n)
#ifdef MATT_COMM_DEBUG
      print '(a,5i6,4es15.5)',"n,copyptr(is-2)+1,copyptr(is),scindx(n),hshs,hsht,hs,ht:",n,copyptr_sc(is_prior)+1, & 
            copyptr_sc(is),l2g(atype(n)),scindx(n),hshs(n),hsht(n),hs(n),ht(n)
#endif
!--- chenge index to point next atom.
      ns=ns+ne
   enddo
!=========================================================== FORCE COPYBACK MODE ====

!===== HSH COPYBACK MODE for SC algorithm of PQeQ==========================
else if(imode==MODE_CPGSGT_SC) then
!   print *, "storing hshs and hsht"
!   is = 7 - dflag !<- [654321] reversed order direction flag
!   is = 7 - dflag !<- [531] reversed order direction flag
   is = 6 - dflag + 2 !<- [642] reversed order direction flag
   !is = 6 - dflag !<- [531] reversed order direction flag
   !is_prior = cptridx_ind_sc(is)

#ifdef MATT_COMM_DEBUG
   print '(a,3i5)',"Start MODE_CPGSGT_SC: is, is-2, dflag:", is, is-2,dflag
#endif

   n = copyptr_sc(is) - copyptr_sc(is-2) + 1
   !n = copyptr_sc(is) - copyptr_sc(is_prior) + 1
   call CheckSizeThenReallocate(sbuffer,n*ne)

   do n=copyptr_sc(is-2)+1, copyptr_sc(is)
   !do n=copyptr_sc(is_prior)+1, copyptr_sc(is)
      sbuffer(ns+1) = dble(scindx(n))
      sbuffer(ns+2) = gssum(n)
      sbuffer(ns+3) = gtsum(n)
#ifdef MATT_COMM_DEBUG
      print '(a,5i6,4es15.5)',"n,copyptr(is-2)+1,copyptr(is),scindx(n),hshs,hsht,hs,ht:",n,copyptr_sc(is_prior)+1, & 
            copyptr_sc(is),l2g(atype(n)),scindx(n),hshs(n),hsht(n),hs(n),ht(n)
#endif
!--- chenge index to point next atom.
      ns=ns+ne
   enddo
!=========================================================== FORCE COPYBACK MODE ====

!===== HSH COPYBACK MODE for SC algorithm of PQeQ==========================
else if(imode==MODE_CPFPQEQ_SC) then
!   print *, "storing hshs and hsht"
!   is = 7 - dflag !<- [654321] reversed order direction flag
!   is = 7 - dflag !<- [531] reversed order direction flag
   is = 6 - dflag + 2 !<- [642] reversed order direction flag
   !is = 6 - dflag !<- [531] reversed order direction flag
   !is_prior = cptridx_ind_sc(is)

#ifdef MATT_COMM_DEBUG
   print '(a,3i5)',"Start MODE_CPGSGT_SC: is, is-2, dflag:", is, is-2,dflag
#endif

   n = copyptr_sc(is) - copyptr_sc(is-2) + 1
   !n = copyptr_sc(is) - copyptr_sc(is_prior) + 1
   call CheckSizeThenReallocate(sbuffer,n*ne)

   do n=copyptr_sc(is-2)+1, copyptr_sc(is)
   !do n=copyptr_sc(is_prior)+1, copyptr_sc(is)
      sbuffer(ns+1) = dble(scindx(n))
      sbuffer(ns+2) = fpqeq(n)
#ifdef MATT_COMM_DEBUG
      print '(a,5i6,4es15.5)',"n,copyptr(is-2)+1,copyptr(is),scindx(n),hshs,hsht,hs,ht:",n,copyptr_sc(is_prior)+1, & 
            copyptr_sc(is),l2g(atype(n)),scindx(n),hshs(n),hsht(n),hs(n),ht(n)
#endif
!--- chenge index to point next atom.
      ns=ns+ne
   enddo
!=========================================================== FORCE COPYBACK MODE ====


endif

!--- if myid is the same of target-node ID, don't use MPI call.
!--- Just copy <sbuffer> to <rbuffer>. Because <send_recv()> will not be used,
!--- <nr> has to be updated here for <append_atoms()>.
if(myid==tn) then
   if(ns>0) then
      nr=ns
      call CheckSizeThenReallocate(rbuffer,nr)
      rbuffer(1:ns) = sbuffer(1:ns)
   else
      nr=0
   endif
endif

call system_clock(tj,tk)
it_timer(26)=it_timer(26)+(tj-ti)

end subroutine store_atoms_sc

!--------------------------------------------------------------------------------------------------------------
subroutine append_atoms_sc(dflag, imode)
use atoms
! <append_atoms> append copied information into arrays
! shared variables::  <ns>, <nr>, <na>, <ne>, <sbuffer()>, <rbuffer()>
!--------------------------------------------------------------------------------------------------------------
implicit none
integer,intent(IN) :: dflag, imode 
integer :: m, i, ine

call system_clock(ti,tk)

if( (na+nr)/ne > NBUFFER) then
    print'(a,i4,5i8)', "ERROR: over capacity in append_atoms; myid,na,nr,ne,(na+nr)/ne,NBUFFER: ", &
         myid,na,nr,ne,(na+nr)/ne, NBUFFER
    call MPI_FINALIZE(ierr)
    stop
endif

!if(imode/=MODE_CPBK .and. imode /=MODE_CPHSH_SC .and. imode /= MODE_CPGSGT_SC .and. imode/=MODE_CPBK_SC &
!    .and. imode /=MODE_CPBKSHELL_SC .and. imode /= MODE_CPFPQEQ_SC) then
if (imode > 0) then !for non-copyback mode
!--- go over the buffered atom
   do i=0, nr/ne-1

!--- get current index <ine> in <rbuffer(1:nr)>.
      ine=i*ne

!--- current atom index; resident + 1 + stored atoms so far + atoms in buffer
      m = NATOMS + 1 + na/ne + i

      select case(imode)
         case(MODE_MOVE)
              pos(m,1:3) = rbuffer(ine+1:ine+3)
              v(m,1:3) = rbuffer(ine+4:ine+6)
              atype(m) = rbuffer(ine+7)
              q(m)  = rbuffer(ine+8)
              qs(m) = rbuffer(ine+9)
              qt(m) = rbuffer(ine+10)
              qsfp(m) = rbuffer(ine+11)
              qsfv(m) = rbuffer(ine+12)
              spos(m,1:3) = rbuffer(ine+13:ine+15)
      
         case(MODE_COPY)
              pos(m,1:3) = rbuffer(ine+1:ine+3)
              atype(m) = rbuffer(ine+4)
              q(m)  = rbuffer(ine+5)
              frcindx(m) = nint(rbuffer(ine+6))
              qs(m) = rbuffer(ine+7)
              qt(m) = rbuffer(ine+8)
              hs(m) = rbuffer(ine+9)
              ht(m) = rbuffer(ine+10)
              spos(m,1:3) = rbuffer(ine+11:ine+13)
 
         case(MODE_COPY_SC)
              pos(m,1:3) = rbuffer(ine+1:ine+3)
              atype(m) = rbuffer(ine+4)
              q(m)  = rbuffer(ine+5)
              !frcindx(m) = nint(rbuffer(ine+6))
              scindx(m) = nint(rbuffer(ine+6))
              qs(m) = rbuffer(ine+7)
              qt(m) = rbuffer(ine+8)
              hs(m) = rbuffer(ine+9)
              ht(m) = rbuffer(ine+10)
              spos(m,1:3) = rbuffer(ine+11:ine+13)
           
           case(MODE_QCOPY1)
              qs(m) = rbuffer(ine+1)
              qt(m) = rbuffer(ine+2)
      
           case(MODE_QCOPY2)
              hs(m) = rbuffer(ine+1)
              ht(m) = rbuffer(ine+2)
              q(m)  = rbuffer(ine+3)

           case(MODE_QCOPY1_SC)
              qs(m) = rbuffer(ine+1)
              qt(m) = rbuffer(ine+2)
              !fpqeq(m) = rbuffer(ine+3)
              !scindx(m) = nint(rbuffer(ine+4))

           case(MODE_QCOPY2_SC)
              hs(m) = rbuffer(ine+1)
              ht(m) = rbuffer(ine+2)
              q(m)  = rbuffer(ine+3)
              !scindx(m) = nint(rbuffer(ine+4))

      end select

     enddo

!===== FORCE COPYBACK MODE =============================================================
else if(imode == MODE_CPBK) then

   do i=0, nr/ne-1
!--- get current index <ine> in <rbuffer(1:nr)>.
      ine=i*ne
!--- Append the transferred forces into the original position of force array.
      m = nint(rbuffer(ine+1))
      f(m,1:3) = f(m,1:3) + rbuffer(ine+2:ine+4)
   enddo

!============================================================== FORCE COPYBACK MODE  ===

!===== HSH COPYBACK MODE for SC algorithm of PQeQ==========================
else if(imode == MODE_CPBKSHELL_SC) then
!   print *, "adding hshs and hsht"
   do i=0, nr/ne-1
!--- get current index <ine> in <rbuffer(1:nr)>.
      ine=i*ne
!--- Append the transferred forces into the original position of force array.
      m = nint(rbuffer(ine+1))
      sforce(m,1:3) = sforce(m,1:3) + rbuffer(ine+2:ine+4)
   enddo



!===== HSH COPYBACK MODE for SC algorithm of PQeQ==========================
else if(imode == MODE_CPBK_SC) then
!   print *, "adding hshs and hsht"
   do i=0, nr/ne-1
!--- get current index <ine> in <rbuffer(1:nr)>.
      ine=i*ne
!--- Append the transferred forces into the original position of force array.
      m = nint(rbuffer(ine+1))
      f(m,1:3) = f(m,1:3) + rbuffer(ine+2:ine+4)
   enddo


!===== HSH COPYBACK MODE for SC algorithm of PQeQ==========================
else if(imode == MODE_CPHSH_SC) then
!   print *, "adding hshs and hsht"
   do i=0, nr/ne-1
!--- get current index <ine> in <rbuffer(1:nr)>.
      ine=i*ne
!--- Append the transferred forces into the original position of force array.
      m = nint(rbuffer(ine+1))
      hshs(m) = hshs(m) + rbuffer(ine+2)
      hsht(m) = hsht(m) + rbuffer(ine+3)
#ifdef MATT_COMM_DEBUG
      print '(a,2i6,6es15.5)',"m,i,hshs(m)_before,hshs(m)_after:",m,i,hshs(m)-rbuffer(ine+2) &
            ,hshs(m),hsht(m)-rbuffer(ine+3),hsht(m),rbuffer(ine+2:ine+3)
#endif
   enddo

!===== GSGT COPYBACK MODE for SC algorithm of PQeQ==========================
else if(imode == MODE_CPGSGT_SC) then
!   print *, "adding hshs and hsht"
   do i=0, nr/ne-1
!--- get current index <ine> in <rbuffer(1:nr)>.
      ine=i*ne
!--- Append the transferred forces into the original position of force array.
      m = nint(rbuffer(ine+1))
      gssum(m) = gssum(m) + rbuffer(ine+2)
      gtsum(m) = gtsum(m) + rbuffer(ine+3)
   enddo


!===== GSGT COPYBACK MODE for SC algorithm of PQeQ==========================
else if(imode == MODE_CPFPQEQ_SC) then
!   print *, "adding hshs and hsht"
   do i=0, nr/ne-1
!--- get current index <ine> in <rbuffer(1:nr)>.
      ine=i*ne
!--- Append the transferred forces into the original position of force array.
      m = nint(rbuffer(ine+1))
      fpqeq(m) = fpqeq(m) + rbuffer(ine+2)
   enddo



endif   
!============================================================== HSH COPYBACK MODE for SC algorithm of PQeQ  =



!--- store the last transfered atom index to <dflag> direction.
!--- if no data have been received, use the index of previous direction.
!if(imode /= MODE_CPBK .and. imode /= MODE_CPHSH_SC .and. imode /= MODE_CPGSGT_SC .and. imode /= MODE_CPBK_SC & 
!     .and. imode /= MODE_CPBKSHELL_SC .and. imode /= MODE_CPFPQEQ_SC) then
if (imode > 0) then !non-copyback mode
  !if(nr==0 .and. (imode == MODE_QCOPY1_SC .or. imode == MODE_QCOPY2_SC .or. imode == MODE_COPY_SC)) then
  if(nr==0 .and. (imode > MODE_SC)) then
     print '(a,2i5)',"imode, dflag:",imode,dflag
     m = copyptr_sc(dflag-2)
  elseif(nr==0) then 
     m = copyptr(dflag-1)
  endif

  !if (imode == MODE_COPY_SC .or. imode == MODE_QCOPY1_SC .or. imode == MODE_QCOPY2_SC) then !update copyptr for sc communication (e.g. 3-ways only)
  if (imode > MODE_SC) then !update copyptr for sc communication (e.g. 3-ways only)
     copyptr_sc(dflag) = m
  else
     copyptr(dflag) = m !update copyptr for 6-way communication
  endif
endif

!--- update the total # of transfered elements.
na=na+nr

call system_clock(tj,tk)
it_timer(27)=it_timer(27)+(tj-ti)

end subroutine append_atoms_sc

!--------------------------------------------------------------------------------------------------------------
real(8) function xshift(dflag)
use atoms
! This subroutine returns a correction value in coordinate for transfered atoms.
!--------------------------------------------------------------------------------------------------------------
implicit none
integer,intent(IN) :: dflag 
integer :: i, j
  
  i = mod(dflag,2)  !<- i=1 means positive, i=0 means negative direction 
  j = int((dflag+1)/2)  !<- [123] means [xyz]

  if(i==1) then
      xshift =-lbox(j)
  else if(i==0) then
      xshift = lbox(j)
  endif
   
!print'(a,i,3f10.3)',"shift: ",myid, xshift
end function

!--------------------------------------------------------------------------------------------------------------
function inBuffer(dflag, idx, dr) result(isInside)
use atoms
!--------------------------------------------------------------------------------------------------------------
implicit none
integer,intent(IN) :: dflag, idx
real(8),intent(IN) :: dr(3)
integer :: i
logical :: isInside

i = mod(dflag,2)  !<- i=1 means positive, i=0 means negative direction 
select case(dflag)
   case(1) 
      isInside = lbox(1) - dr(1) < pos(idx,1)
   case(2) 
      isInside = pos(idx,1) <= dr(1)
   case(3) 
      isInside = lbox(2) - dr(2) < pos(idx,2)
   case(4) 
      isInside = pos(idx,2) <= dr(2)
   case(5) 
      isInside = lbox(3) - dr(3) < pos(idx,3)
   case(6) 
      isInside = pos(idx,3) <= dr(3)
   case default
      write(6,*) "ERROR: no matching directional flag in isInside: ", dflag
end select

end function

!--------------------------------------------------------------------------------------------------------------
subroutine CheckSizeThenReallocate(buffer,nsize)
implicit none
!--------------------------------------------------------------------------------------------------------------
real(8),allocatable :: buffer(:)
integer,intent(IN) :: nsize
integer :: ast

if(allocated(buffer)) then
   if(nsize > size(buffer)) then
       deallocate(buffer)
       allocate(buffer(2*nsize), stat=ast)
   endif
else
   allocate(buffer(nsize), stat=ast)
endif

end subroutine

end subroutine COPYATOMS_SC
